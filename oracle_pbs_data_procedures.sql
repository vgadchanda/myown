-- Generated by Ora2Pg, the Oracle database Schema converter, version 19.1
-- Copyright 2000-2018 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=localhost;sid=orcl;port=1521

SET client_encoding TO 'UTF8';

SET search_path = pbs_data;
\set ON_ERROR_STOP ON



CREATE OR REPLACE FUNCTION pbs_data.sppc_data_uniqueid ( ReturnKey OUT text, tpyPrefix text, tpyOrganization text, tsuffix text) AS $body$
DECLARE


--
-- $Id: sppc_data_uniqueid.sql,v 1.4 2007/09/13 23:37:37 dsila Exp $
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppc_data_uniqueid
--
-- Generate a Unique ID for a Work Item
--
-- Date         Who     RuleProID       Description of Modification
-- 21-Jan-03    GajnJ                   Handle errors from insert
-- 16-Aug-02    LawtT                   Enforce uniqueness
-- 30-Jul-02    GajnJ                   Initial Work
--
tpxCreateDateTime  	timestamp;
tpxCreateOpName 	varchar(128);
tpxCreateOperator 	varchar(128);
tpxCreateSystemID 	varchar(32);
tpxInsName			varchar(128);
tpxObjClass		    varchar(96);
tpxUpdateDateTime 	timestamp;
tpxUpdateOpName 	varchar(128);
tpxUpdateOperator 	varchar(128);
tpxUpdateSystemID 	varchar(32);
tpyLabel 		    varchar(64);
tpyLastReservedID	bigint;
tpzInsKey			varchar(255);

tnewLastReservedID	bigint;
tupdater		char(1);


BEGIN

tpxCreateDateTime := NULL;
tpxCreateOpName := NULL;
tpxCreateOperator := NULL;
tpxCreateSystemID := NULL;
tpxInsName := upper(tpyOrganization || '!' || tpyPrefix);
tpxObjClass := 'Data-UniqueID';
tpxUpdateDateTime := NULL;
tpxUpdateOpName := NULL;
tpxUpdateOperator := NULL;
tpxUpdateSystemID := NULL;
tpyLabel := NULL;
tpzInsKey := upper(tpxObjClass || ' ' || tpyOrganization || '!' || tpyPrefix);

tnewLastReservedID := 1;
tpyLastReservedID := 1;
ReturnKey := tpyPrefix || tnewLastReservedID || tsuffix;

begin -- protective block
Select pyLastReservedID into STRICT tpyLastReservedID from PBS_DATA.pc_data_uniqueid where pzInsKey = tpzInsKey for update;

tnewLastReservedID := tpyLastReservedID + 1;
Update PBS_DATA.pc_data_uniqueid
		set pyLastReservedID = tnewLastReservedID
		where pzInsKey = tpzInsKey;
ReturnKey := tpyPrefix || tnewLastReservedID || tsuffix;

EXCEPTION
when NO_DATA_FOUND then
		insert into PBS_DATA.pc_data_uniqueid( pxCreateDateTime,
			  pxCreateOpName,
			  pxCreateOperator,
			  pxCreateSystemID,
			  pxInsName,
			  pxObjClass,
			  pxUpdateDateTime,
			  pxUpdateOpName,
			  pxUpdateOperator,
			  pxUpdateSystemID,
			  pyLabel,
			  pyLastReservedID,
			  pyOrganization,
			  pyPrefix,
			  pzInsKey)		
		values ( tpxCreateDateTime,
			  tpxCreateOpName,
			  tpxCreateOperator,
			  tpxCreateSystemID,
			  tpxInsName,
			  tpxObjClass,
			  tpxUpdateDateTime,
			  tpxUpdateOpName,
			  tpxUpdateOperator,
			  tpxUpdateSystemID,
			  tpyLabel,
			  tpyLastReservedID,
			  tpyOrganization,
			  tpyPrefix,
			  tpzInsKey);
end; -- protective block
exception when unique_violation then
  Select pyLastReservedID into STRICT tpyLastReservedID from PBS_DATA.pc_data_uniqueid where pzInsKey = tpzInsKey for update;

  tnewLastReservedID := tpyLastReservedID + 1;
  Update PBS_DATA.pc_data_uniqueid
		set pyLastReservedID = tnewLastReservedID
		where pzInsKey = tpzInsKey;
  ReturnKey := tpyPrefix || tnewLastReservedID || tsuffix;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pbs_data.sppc_data_uniqueid ( ReturnKey OUT text, tpyPrefix text, tpyOrganization text, tsuffix text) FROM PUBLIC;



--
-- $Id: sppr_aggregate_usage.sql,v 1.15 2008/11/20 14:28:18 dsila Exp $
--
-- Copyright (c) 2006  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppr_aggregate_usage
--
-- Aggregate the usage data into daily and summary tables
--
-- Date			Who		RuleProID	Description of Modification
-- 20-Nov-08	dsila	SR-19864	Added a second check on maxocchoursperPeriod
-- 07-Nov-08	dsila   SR-19864    Parameters in license.txt not set correctly
-- 20-Mar-07	dsila	Bug-3317    Added a dummy union to num user SQL so that only 
--									having web and services users don't cause an error
-- 12-Feb-07	dsila	Bug-2337	Updated so that multi-node configurations will
--									accurately account the same user logged into different
--									nodes.
-- 11-Nov-06    dsila				Updated with corrected peak statistics
-- 12-Oct-06	dsila				Updated with error handling
-- 20-Sep-06	dsila				Initial Work
--
CREATE OR REPLACE FUNCTION pbs_data.sppr_aggregate_usage () RETURNS VOID AS $body$
DECLARE


sqlStmt varchar(5000);
periodSql varchar(1024);
periodEndSql varchar(1024);
periodHourSql varchar(1024);
modifiedRulesClause varchar(1024);
modifiedRulesNotClause varchar(1024);
modifiedRulesNotClause1 varchar(1024);

/*Variables for summary calculations */
processPeriod varchar(32);
regUserMaxDailyHours bigint;
regUserMinDailyHours bigint;
regUserMinPeriodHours bigint;
occUserMaxDailyHours bigint;
occUserMinDailyHours bigint;
occUserMinPeriodHours bigint;
occUserMaxPeriodHours bigint;
sprUserMaxPeriodHours bigint;
interactionsNamedUsers bigint;
invocationsNamedUsers bigint;
interactionsServices bigint;
invocationsServices bigint;
interactionsWebUsers bigint;
invocationsWebUsers bigint;
/* Set the first day of the week if needed */
firstDayOfWeek bigint;
ruleUserRegular bigint;
workingperiod timestamp;
maxdailyperiod timestamp;
retaindaily bigint;
retainhourly bigint;
cur_error varchar(128);

BEGIN
EXECUTE 'ALTER SESSION SET TIME_ZONE=''GMT''';
/*  Get the measurment period i.e w-weekly, q-quarterly, m-monthly, y-yearly */
BEGIN
  cur_error := 'No data found for variable :pyMeasurementPeriod';
  select pyvalue INTO STRICT processPeriod  from PBS_DATA.PR_LICENSE_PARAMETERS where pyName = 'pyMeasurementPeriod' and pyUserType = 'SYSTEM';
  /* Get the parameters for calculating the license usage */
  cur_error := 'No data found for variable :pyMaxHoursPerDay:occasional';
  SELECT pyValue INTO STRICT occUserMaxDailyHours FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'occasional' and pyName = 'pyMaxHoursPerDay';
  cur_error := 'No data found for variable :pyMinHoursPerDay:occasional';
  SELECT pyValue INTO STRICT occUserMinDailyHours FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'occasional' and pyName = 'pyMinHoursPerDay';
  cur_error := 'No data found for variable :pyMinHoursPerPeriod:occasional';
  SELECT pyValue INTO STRICT occUserMinPeriodHours FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'occasional' and pyName = 'pyMinHoursPerPeriod';
  cur_error := 'No data found for variable :pyMaxHoursPerPeriod:occasional';
  SELECT pyValue INTO STRICT occUserMaxPeriodHours FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'occasional' and pyName = 'pyMaxHoursPerPeriod';
  cur_error := 'No data found for variable :pyMaxHoursPerPeriod:sporadic';
  SELECT pyValue INTO STRICT sprUserMaxPeriodHours FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'sporadic' and pyName = 'pyMaxHoursPerPeriod';
  cur_error := 'No data found for variable :pyMaxHoursPerDay:Regular';
  SELECT pyValue INTO STRICT regUserMaxDailyHours FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'regular' and pyName = 'pyMaxHoursPerDay';
  cur_error := 'No data found for variable :pyMinHoursPerDay:Regular';
  SELECT pyValue INTO STRICT regUserMinDailyHours FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'regular' and pyName = 'pyMinHoursPerDay';
  cur_error := 'No data found for variable :pyMaxHoursPerPeriod:Regular';
  SELECT pyValue INTO STRICT regUserMinPeriodHours FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'regular' and pyName = 'pyMinHoursPerPeriod';
  cur_error := 'No data found for variable :pyRuleUserForcesRegular';
  SELECT pyValue INTO STRICT ruleUserRegular FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'SYSTEM' and pyName = 'pyRuleUserForcesRegular';
  cur_error := 'No data found for variable :pyRetainDaily';
  SELECT pyValue INTO STRICT retainDaily FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'SYSTEM' and pyName = 'pyRetainDaily';
  cur_error := 'No data found for variable :pyRetainHourly';
  SELECT pyValue INTO STRICT retainHourly FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'SYSTEM' and pyName = 'pyRetainHourly';
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE EXCEPTION '%', cur_error USING ERRCODE = '45001';
  WHEN OTHERS THEN
    RAISE;
END;

/* Bug in the setup of license parameters - hence fix and backup calculation here */
/* Note ordering of the IF statements below is important - DONOT CHANGE - Anil */
  IF sprUserMaxPeriodHours <> 0 AND sprUserMaxPeriodHours >= regUserMinPeriodHours  THEN
     regUserMinPeriodHours := sprUserMaxPeriodHours+1;
  END IF;
  IF occUserMaxPeriodHours <> 0 AND occUserMaxPeriodHours <> 9000 AND occUserMaxPeriodHours > regUserMinPeriodHours THEN
     regUserMinPeriodHours := occUserMaxPeriodHours+1;
  END IF;
  IF occUserMaxPeriodHours = 0 THEN
  	 occUserMaxPeriodHours := 9000;
  END IF;
  /* End ordering of IF statements and licence UI Bug fix */
  
/* Convert processPeriod to the SQL Server DATEPART equivalent */
CASE processPeriod
  WHEN 'W' THEN      /* For weekly periods */
     BEGIN
      select pyValue INTO STRICT firstDayOfWeek FROM PBS_DATA.PR_LICENSE_PARAMETERS where pyUserType = 'SYSTEM' and pyName = 'pyFirstDayOfWeek';
     EXCEPTION
     WHEN NO_DATA_FOUND THEN
        firstDayOfWeek := 1;
     WHEN OTHERS THEN
        RAISE;
     END;
     periodSql := 'TRUNC(pzUsageDay, ''D'') + ' || firstdayOfWeek || ' - 1';
     periodEndSql := 'TRUNC(pzUsageDay, ''D'') + ' || firstdayOfWeek || ' +5+86399/86400';
     periodHourSql := 'TRUNC(pzPeriodEnding, ''D'') + ' || firstdayOfWeek || ' - 1';
     retaindaily := retaindaily + 7;
  WHEN 'M' THEN
    periodSql := 'TRUNC(pzUsageDay, ''MM'')';
    periodEndSql := 'ADD_MONTHS(TRUNC(pzUsageDay, ''MM''),1) - 86399/86400';
    periodHourSql := 'TRUNC(pzPeriodEnding, ''MM'')';
    retaindaily := retaindaily + 31;
  WHEN 'Q' THEN
    periodSql := 'TRUNC(pzUsageDay, ''Q'')';
    periodEndSql := 'ADD_MONTHS(TRUNC(pzUsageDay, ''Q''),3) - 86399/86400';
    periodHourSql := 'TRUNC(pzPeriodEnding, ''Q'')';
    retaindaily := retaindaily + 92;
  WHEN 'Y' THEN
    periodSql := 'TRUNC(pzUsageDay, ''YY'')';
    periodEndSql := 'ADD_MONTHS(TRUNC(pzUsageDay, ''YY''),12) - 86399/86400';
    periodHourSql := 'TRUNC(pzPeriodEnding, ''YY'')';
    retaindaily := retaindaily + 366;
  ELSE
   RAISE EXCEPTION '%', 'The value of parameter pyMeasurementPeriod cannot be recognized. ' USING ERRCODE = '45002';
END CASE;

BEGIN
    sqlStmt :=          ' SELECT min(usagePeriod) from ( Select (' || periodSql || ') as usagePeriod FROM ( select pzPeriodEnding as pzUsageDay from PBS_DATA.pr_hourly_usage ) S
                        where pzUsageDay < TRUNC(current_date-1)+86399/86400
                              AND pzUsageDay > (select DECODE( max(pzUsageDay), NULL, TO_DATE(''01/01/1990'', ''DD/MM/YYYY''),  max(pzUsageDay) ) from PBS_DATA.pr_daily_usage )
                        group by (' || periodSql || ') )';

/* DBMS_OUTPUT.PUT_LINE(sqlStmt);  */
EXECUTE sqlStmt INTO STRICT workingPeriod;
IF workingPeriod IS NULL THEN
   RAISE NO_DATA_FOUND;
END IF;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
       RAISE NOTICE 'No data to process';
       RETURN;
    WHEN OTHERS THEN
      RAISE;
END;


INSERT INTO PBS_DATA.pr_daily_usage (SELECT TRUNC(h.pzPeriodEnding,'DD')+86399/86400 as pzUsageDay,
       h.pzUserId as pzUserId, h.pzUserType as pzUsertype, max(h.pzMayCheckOutRules) as pzMayCheckOutRules,
       sum(h.pzModifiedRulesCount) as pzModifiedRulesCount, sum(h.pzInteractionCount) as pzInteractionCount,
       sum(h.pzInvocationCount) as pzInvocationCount, count(h.pzUserId) as pzUsageHoursCount,
       sum(h.pzNoInvocationUserCount) as pzNoInvocationUserCount, sum(h.pzNoInvocationFlowCount) as pzNoInvocationFlowCount,
       MAX(h.pzUserAdditionalInfo) KEEP(DENSE_RANK FIRST ORDER BY h.pzPeriodEnding, pzUserId) as pzUserAdditionalInfo
from (select  TRUNC(pzPeriodEnding, 'HH')+3599/86400 pzPeriodEnding, pzUserId, pzUserType, max(pzMayCheckOutRules) as pzMayCheckOutRules, 
sum(pzModifiedRulesCount) as pzModifiedRulesCount, sum(pzInteractionCount) as pzInteractionCount, 
sum(pzInvocationCount) as pzInvocationCount, sum(pzNoInvocationFlowCount) as pzNoInvocationFlowCount,
sum(pzNoInvocationUserCount) as pzNoInvocationUserCount, 
MAX(pzUserAdditionalInfo) KEEP(DENSE_RANK FIRST ORDER BY pzPeriodEnding, pzUserId) as pzUserAdditionalInfo
from PBS_DATA.pr_hourly_usage
group by TRUNC(pzPeriodEnding, 'HH')+3599/86400, pzUserId, pzUserType)  h
GROUP BY pzUserId,pzUserType, TRUNC(h.pzPeriodEnding,'DD')+86399/86400
HAVING  TRUNC(h.pzPeriodEnding,'DD')+86399/86400 > (select CASE WHEN max(pzUsageDay) IS NULL THEN  TO_DATE('01/01/1990', 'DD/MM/YYYY')  ELSE max(pzUsageDay) END  from PBS_DATA.pr_daily_usage )
       AND TRUNC(h.pzPeriodEnding,'DD')+86399/86400 <= date_trunc('day', current_date-1)+86399/86400);



sqlStmt :=           ' insert into PBS_DATA.pr_usage_summary
                       select  distinct ''' || processPeriod || ''' as pySummarytype, ' || periodSql || ' as PyPeriodStarts, ' || periodEndSql ||
                                 ' as PyPeriodEnds, TRUNC(current_date-1)+86399/86400 as pyPeriodAsOf, ' || periodSql || ' PYPEAKHOUROFUSE,
                                   0 PYPEAKHOURUSERS, ' || periodSql || ' PYPEAKDAYOFUSE,0 PYPEAKDAYUSERS,0 PYDISTINCTUSERSTOTAL,
                                   0 PYDISTINCTUSERSSPORADIC, 0 PYDISTINCTUSERSOCCASIONAL,0 PYDISTINCTUSERSREGULAR,0 PYINTERACTIONSNAMEDUSERS,
                                   0 PYINTERACTIONSWEBUSERS,0 PYINTERACTIONSSERVICES, 0 PYINVOCATIONSNAMEDUSERS,0 PYINVOCATIONSWEBUSERS,
                                   0 PYINVOCATIONSSERVICES,0 PYNOINVOCATIONFLOWNAMEDUSERS,0 PYNOINVOCATIONUSERNAMEDUSERS,
                                   0 PYNOINVOCATIONFLOWWEBUSERS,0 PYNOINVOCATIONUSERWEBUSERS,0 PYNOINVOCATIONFLOWSERVICES,0 PYNOINVOCATIONUSERSERVICES
                        from PBS_DATA.pr_daily_usage where ' || periodSql || '  > (SELECT DECODE(MAX(pyPeriodStarts)+86399/86400, NULL, TO_DATE(''01/01/1990'', ''DD/MM/YYYY''),MAX(pyPeriodStarts)+86399/86400)  from PBS_DATA.pr_usage_summary ) ';
-- DBMS_OUTPUT.PUT_LINE(sqlStmt);
EXECUTE sqlStmt;

IF ruleUserRegular = 1 THEN
        modifiedRulesClause :=                        ' UNION SELECT distinct ' || periodSql || ' periodstart, pzUserId ';
        modifiedRulesClause := modifiedRulesClause || '       FROM PBS_DATA.pr_daily_usage ';
        modifiedRulesClause := modifiedRulesClause || '       WHERE (pzMayCheckOutRules = 1 OR pzModifiedRulesCount > 0) AND (pzUserType = ''H'' ';
        modifiedRulesClause := modifiedRulesClause || '              AND ' || periodSql || ' >= TO_DATE(''' || workingperiod || ''') ) ';
	modifiedRulesNotClause := ' AND pzMayCheckOutRules = 0 AND pzModifiedRulesCount = 0 ';
	modifiedRulesNotClause1 := ' AND max(pzMayCheckOutRules) = 0 AND max(pzModifiedRulesCount) = 0 ';

ELSE
	modifiedRulesClause :=   ' ';
	modifiedRulesNotClause := ' ';
	modifiedRulesNotClause1 := ' ';
END IF;

/* Now construct a string that represents the SQL to calculate the summary information
   Description: Each of the UNION sub clauses calculate the number of users for each type in the period.
                The UNIONED data is pivoted around so that you get one row for each period
                For Regular Users -     Equi-join the users who meet the hourly requirements for the period with
					the users have days within the period with use greater than specified limits.
					Also include those users who may have rule checkout privs or have checked out rules
					Within that period.
		For Occassional Users - Equi-join the users who meet the hourly requirements for the period filtered
					by only those users who are not rule developers for the period with the users
					who meet the daily requirements for the period
		For Sporadic Users - Just get the list of users who never have more than the max hourly req
				     for the period


*/
sqlStmt :=            'update PBS_DATA.pr_usage_summary  set (pyPeriodStarts, pyDistinctUsersRegular, pyDistinctUsersOccasional, pyDistinctUsersSporadic, pyDistinctUsersTotal) =
                         (select periodstart, max(regular) as pyDistinctUsersRegular, max(occasional) as pyDistinctUsersOccasional, max(sporadic) as pyDistinctUsersSporadic,
                                  max(regular)+ max(occasional)+ max(sporadic) as pyDistinctUsersTotal
                          FROM (Select periodstart, count(pzuserid) as regular, 0 as occasional, 0 as sporadic
                                FROM (SELECT d.periodstart periodstart, d.pzUserId pzUserId
                                    FROM (SELECT distinct ' || periodSql || ' periodstart, pzUserId
                                          FROM PBS_DATA.pr_daily_usage
                                          WHERE pzUserType = ''H''
                                          GROUP BY pzuserid, '  || periodSql ||
                                        ' HAVING sum(pzUsageHoursCount) >= ' || regUserMinPeriodHours || ' ' || modifiedRulesNotClause1 ||
                                        ') p,
                                        (SELECT distinct ' || periodSql || ' periodstart, pzUserId
                                         FROM PBS_DATA.pr_daily_usage du
                                         WHERE pzUsageHoursCount >= '  || regUserMinDailyHours || ' and pzUsageHoursCount <= ' || regUserMaxDailyHours ||
                                             ' AND pzUserType = ''H'' '  || modifiedRulesNotClause || ' ) d
                                    WHERE p.periodstart = d.periodstart and  p.pzUserId=d.pzUserId ' || modifiedRulesClause || ' ) s
                                WHERE periodstart >= TO_DATE(''' || workingPeriod || ''')
                                GROUP BY periodstart
                                UNION
                                SELECT periodstart, 0 as regular, count(pzuserid) as occasional, 0 as sporadic
                                FROM (SELECT distinct d.periodstart, d.pzUserId
                                    FROM (SELECT distinct '  || periodSql || ' periodstart, pzUserId
                                          FROM PBS_DATA.pr_daily_usage where pzUserType = ''H'' GROUP BY pzuserid, ' || periodSql ||
                                        ' HAVING sum(pzUsageHoursCount) >= ' || occUserMinPeriodHours || ' and sum(pzUsageHoursCount) <= ' || occUserMaxPeriodHours || ' ' ||  modifiedRulesNotClause1 ||
                                        ' ) p,
                                          (SELECT distinct ' || periodSql || ' periodstart, pzUserId
                                           FROM PBS_DATA.pr_daily_usage du WHERE  pzUserType = ''H'' ' || modifiedRulesNotClause ||
                                         ' GROUP BY ' || periodSql || ', pzUserId ' ||
                                         ' HAVING min(pzUsageHoursCount) > ' || occUserMinDailyHours || ' and max(pzUsageHoursCount) <= ' || occUserMaxDailyHours ||
                                         ' ) d
                                    WHERE p.periodstart = d.periodstart and  p.pzUserId=d.pzUserId ) s
                                WHERE periodstart >= TO_DATE(''' || workingPeriod || ''')
                                group by periodstart
                                UNION
                                SELECT periodstart, 0 as regular, 0 as occasional, count(pzuserid) as sporadic
                                FROM ( select ' || periodSql || ' periodstart, pzUserId
                                     from PBS_DATA.pr_daily_usage WHERE pzUserType = ''H''
                                     group by pzuserid, ' || periodSql ||
                                   ' having sum(pzUsageHoursCount) <= '  || sprUserMaxPeriodHours || ' ' || modifiedRulesNotClause1 || ')  s
                                WHERE periodstart >= TO_DATE(''' || workingPeriod || ''')
                                group by periodstart 
                                UNION 
                                SELECT ' || periodSql || ' periodstart, 0 as regular, 0 as occasional, 0 as sporadic
                                FROM  PBS_DATA.pr_daily_usage 
                                WHERE (pzUserType = ''W'' OR pzUserType = ''S'' OR pzUserType = ''A'') AND ' || periodSql || ' >= TO_DATE(''' || workingPeriod || ''')
                                GROUP BY ' || periodSql || ' )  t
                         group by periodstart having PBS_DATA.pr_usage_summary.pyPeriodStarts = periodstart )
                         WHERE PBS_DATA.pr_usage_summary.pyPeriodStarts >= TO_DATE(''' || workingPeriod || ''')';

/*  DBMS_OUTPUT.PUT_LINE(sqlStmt);  */
 EXECUTE sqlStmt;

/* Now update the period rows with peak hours  */
sqlStmt :=            'update PBS_DATA.pr_usage_summary  set (pypeakhourofuse, pypeakhourusers) = (select  min(h.pzPeriodEnding) maxhour, maxusers
                       from (select DISTINCT ' ||periodHourSql || ' periodStart, max(noofusers) maxusers
                             FROM (select pzPeriodEnding, count(pzuserid) as noofusers
                                   from PBS_DATA.pr_hourly_usage where pzUserType = ''H'' and  pzPeriodEnding > TO_DATE(''' || workingPeriod || ''')
                                   group by pzPeriodEnding
                                   UNION
                                   select pyPeakHourOfUse as pzPeriodEnding, pyPeakHourUsers as noofusers from PBS_DATA.pr_usage_summary where pyPeriodStarts >= TO_DATE(''' || workingPeriod || ''')
                                   ) group by ' || periodHourSql || ') s,
                                  (select pzPeriodEnding, count(pzuserid) as noofusers
                                   from PBS_DATA.pr_hourly_usage where pzUserType = ''H'' and  pzPeriodEnding > TO_DATE(''' || workingPeriod || ''') group by pzPeriodEnding
                                   UNION 
                                   select pyPeakHourOfUse as pzPeriodEnding, pyPeakHourUsers as noofusers from PBS_DATA.pr_usage_summary where pyPeriodStarts >= TO_DATE(''' || workingPeriod || ''')) h
                            where s.periodstart = ' || periodHourSql || '  and  maxusers=noofusers
                            group by s.periodStart, maxusers having PBS_DATA.pr_usage_summary.pyPeriodStarts=s.periodStart)
                        where PBS_DATA.pr_usage_summary.pyPeriodStarts >= TO_DATE(''' || workingPeriod || ''') ';

 RAISE NOTICE '%', sqlStmt;
EXECUTE sqlStmt;

 /* Now update the period rows with peak days  */
 sqlStmt :=            'update PBS_DATA.pr_usage_summary  set (pypeakdayofuse, pypeakdayusers) =
                           (select  min(h.pzusageDay) maxday, maxusers
                            from (select DISTINCT ' ||periodSql || ' periodStart, FIRST_VALUE(noofusers) OVER( PARTITION BY ' || periodSql ||
                                                                                                          ' ORDER BY noofusers DESC) maxusers
                                  FROM (select pzUsageDay, count(pzuserid) as noofusers
                                        from PBS_DATA.pr_daily_usage where pzUserType = ''H'' and  pzUsageDay > TO_DATE(''' || workingPeriod || ''')
                                        group by pzUsageDay)) s,
                                       (select pzUsageDay, count(pzuserid) as noofusers
                                        from PBS_DATA.pr_daily_usage where pzUserType = ''H'' and  pzUsageDay > TO_DATE(''' || workingPeriod || ''')group by pzUsageDay) h
                                  where s.periodstart = ' || periodSql || '  and  maxusers=noofusers
                            group by s.periodStart, maxusers having PBS_DATA.pr_usage_summary.pyPeriodStarts=s.periodStart)
                        where PBS_DATA.pr_usage_summary.pyPeriodStarts >= TO_DATE(''' || workingPeriod || ''')';

/* DBMS_OUTPUT.PUT_LINE(sqlStmt);  */
EXECUTE sqlStmt;


sqlStmt := 'Update PBS_DATA.pr_usage_summary set (pyInteractionsNamedUsers , pyInvocationsNamedUsers , pyNoInvocationFlowNamedUsers , pyNoInvocationUserNamedUsers ) =
            (Select  sum(du.pzInteractionCount) as pyInteractionsNamedUsers,
		              sum(du.pzInvocationCount) as pyInvocationsNamedUsers, sum(du.pzNoInvocationFlowCount) as pyNoInvocationFlowNamedUsers,
			      sum(du.pzNoInvocationUserCount) as pyNoInvocationUserNamedUsers
		       from PBS_DATA.pr_daily_usage du
       		       where  du.pzUserType = ''H''
       		       group by (' || periodSql ||  ')
                       having PBS_DATA.pr_usage_summary.pyPeriodStarts= ' || periodSql ||' )
            where PBS_DATA.pr_usage_summary.pyPeriodStarts >= TO_DATE(''' || workingPeriod || ''')';
/* DBMS_OUTPUT.PUT_LINE(sqlStmt);  */
EXECUTE sqlStmt;

sqlStmt := 'Update PBS_DATA.pr_usage_summary set (pyInteractionsServices , pyInvocationsServices , pyNoInvocationFlowServices , pyNoInvocationUserServices ) =
            (Select  sum(du.pzInteractionCount) pyInteractionsServices,
		              sum(du.pzInvocationCount) pyInvocationsServices, sum(du.pzNoInvocationFlowCount) pyNoInvocationFlowServices,
			      sum(du.pzNoInvocationUserCount) pyNoInvocationUserServices
		       from PBS_DATA.pr_daily_usage du
       		       where  du.pzUserType = ''S''
       		       group by (' || periodSql ||  ')
                       having PBS_DATA.pr_usage_summary.pyPeriodStarts = ' || periodSql || ')
            where PBS_DATA.pr_usage_summary.pyPeriodStarts >= TO_DATE(''' || workingPeriod || ''')';
/* DBMS_OUTPUT.PUT_LINE(sqlStmt);  */
EXECUTE sqlStmt;

sqlStmt := 'Update PBS_DATA.pr_usage_summary set (pyInteractionsWebUsers , pyInvocationsWebUsers , pyNoInvocationFlowWebUsers , pyNoInvocationUserWebUsers ) =
            (Select  sum(du.pzInteractionCount) pyInteractionsWebUsers,
		              sum(du.pzInvocationCount) pyInvocationsWebUsers, sum(du.pzNoInvocationFlowCount) pyNoInvocationFlowWebUsers,
			      sum(du.pzNoInvocationUserCount) pyNoInvocationUserWebUsers
		       from PBS_DATA.pr_daily_usage du
       		       where  du.pzUserType = ''A'' OR du.pzUserType = ''W''
       		       group by (' || periodSql ||  ')
                       having PBS_DATA.pr_usage_summary.pyPeriodStarts = ' || periodSql || ')
            where PBS_DATA.pr_usage_summary.pyPeriodStarts >= TO_DATE(''' || workingPeriod || ''')';
/* DBMS_OUTPUT.PUT_LINE(sqlStmt); */
EXECUTE sqlStmt;

/* Finally update the last updated date */
sqlStmt := 'Update PBS_DATA.pr_usage_summary set PYPERIODASOF = TRUNC(current_date-1)+86399/86400 where PBS_DATA.pr_usage_summary.pyPeriodStarts >= TO_DATE(''' || workingPeriod || ''')';
/* DBMS_OUTPUT.PUT_LINE(sqlStmt); */
EXECUTE sqlStmt;

PERFORM sppr_purge_table('PBS_DATA.pr_hourly_usage', 'pzPeriodEnding', retainhourly);
PERFORM sppr_purge_table('PBS_DATA.pr_daily_usage', 'pzUsageDay', retaindaily);

COMMIT WORK;
EXCEPTION
  WHEN OTHERS THEN ROLLBACK;
  RAISE;
End;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pbs_data.sppr_aggregate_usage () FROM PUBLIC;



--
-- $Id: sppr_populate_index_data.sql,v 1.1 2009/01/16 20:54:26 alibj Exp $
--
-- Copyright (c) 2006  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppr_populate_index_data
--
-- Aggregate the usage data into daily and summary tables
--
-- Date			Who		RuleProID	Description of Modification
-- 20-Sep-06	dsila				Initial Work
--
CREATE OR REPLACE FUNCTION pbs_data.sppr_populate_index_data (req_id text, table_of_interest text) RETURNS VOID AS $body$
BEGIN
   delete from PBS_DATA.PR_INDEX_INFO 
      where PYTABLENAME = UPPER(table_of_interest) and PYREQUESTORID = req_id;
   insert into PBS_DATA.PR_INDEX_INFO(PYINDEXNAME, PYCOLUMNNAME, PYTABLENAME, PYREQUESTORID)
       SELECT USER_INDEXES.INDEX_NAME, COLUMN_NAME, 
                      USER_INDEXES.TABLE_NAME, Req_id
                 from USER_IND_COLUMNS, USER_INDEXES
                 where 
                      USER_IND_COLUMNS.INDEX_NAME=USER_INDEXES.INDEX_NAME and 
                      USER_INDEXES.TABLE_NAME=UPPER(table_of_interest);
EXCEPTION
  WHEN OTHERS THEN RETURN;
END;
$body$
LANGUAGE PLPGSQL
;
-- REVOKE ALL ON FUNCTION pbs_data.sppr_populate_index_data (req_id text, table_of_interest text) FROM PUBLIC;



--
-- $Id: sppr_purge_table.sql,v 1.5 2007/09/13 23:37:37 dsila Exp $
--
-- Copyright (c) 2006  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppr_purge_table
--
-- Generate a Unique ID for a Work Item
--
-- Date			Who		RuleProID	Description of Modification
-- 20-Sep-06	dsila				Initial Work
--
CREATE OR REPLACE FUNCTION pbs_data.sppr_purge_table (tablename text, columnname text, purgedays bigint) RETURNS VOID AS $body$
DECLARE

sqlStmt varchar(1024);

BEGIN
IF tablename IS NOT NULL THEN
  IF (purgedays IS NOT NULL) AND (COLUMNNAME IS NOT NULL) THEN
    sqlStmt := 'delete from ' || tablename || ' where ' || columnname || ' < (select TRUNC(max(' || columnname || '), ''DD'') - ' || purgedays::varchar || ' from ' || tablename || ') ';
  ELSE
    sqlStmt := 'delete from ' || tablename;
  END IF;
  /* DBMS_OUTPUT.PUT_LINE(sqlStmt); */
  EXECUTE sqlStmt;
ELSE
  RAISE EXCEPTION '%', 'No table specified for purge' USING ERRCODE = '45003';
END IF;
END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pbs_data.sppr_purge_table (tablename text, columnname text, purgedays bigint) FROM PUBLIC;



--
-- $Id: sppr_sys_getindextime.sql,v 1.4 2007/09/13 23:37:37 dsila Exp $
--
-- Copyright (c) 2003  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppr_sys_getindextime
--
-- Returns the last pulse time and the current database time
--
-- Date			Who		RuleProID	Description of Modification
-- 12-Aug-03	ChauD	R-9929		Initial coding to let engine generate
--									pulse queries instead of using temp tables,
--									obsoletes prepare and finalize stored procs.
--
 
CREATE OR REPLACE FUNCTION pbs_data.sppr_sys_getindextime (SPlastPulseTime out timestamp, SPcurrentTime out timestamp, SPnodePZInsKey text) AS $body$
BEGIN
	select min(pyLastIndexBuildDateTime) into STRICT SPlastPulseTime
		from PBS_DATA.pr_sys_statusnodes where pzInsKey = SPnodePZInsKey;
	SPlastPulseTime := coalesce(SPlastPulseTime, to_date('19700101', 'yyyymmdd'));
	SPcurrentTime := clock_timestamp();
end;
$body$
LANGUAGE PLPGSQL
;
-- REVOKE ALL ON FUNCTION pbs_data.sppr_sys_getindextime (SPlastPulseTime out timestamp, SPcurrentTime out timestamp, SPnodePZInsKey text) FROM PUBLIC;



--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppr_sys_reservequeueitem
--
-- Reserve the next available queue item that matches the criteria.  If
-- ProcessingNodeId is null, then just select the next available
-- item without locking it.
--
-- Date			Who		RuleProID	Description of Modification
-- 21-Jan-09	MiraT	Bug-4274	Call through to sppr_sys_reservequeueitem_b
-- 01-Aug-08	MiraT	Task-991	Add priority
-- 24-Oct-07	DsilA				Made transaction serializable on Oracle
-- 18-Oct-07	DsilA	Bug-8055	Added a sortable string value
-- 13-Sep-07	DsilA				initial coding
-- 09-Oct-07	Dsila				Update to insure concurrency works.
--
 
CREATE OR REPLACE FUNCTION pbs_data.sppr_sys_reservequeueitem (TableName text, InsKey out text, ObjClass text, AgentName text, ItemStatus text, ProcessingNodeId text, PreviousInsKey text, LastExecutionDateTime timestamp) AS $body$
BEGIN
InsKey := SPPR_SYS_RESERVEQUEUEITEM_B(TableName, ObjClass, AgentName, ItemStatus, ProcessingNodeId, PreviousInsKey, LastExecutionDateTime, null, null);
end;
$body$
LANGUAGE PLPGSQL
;
-- REVOKE ALL ON FUNCTION pbs_data.sppr_sys_reservequeueitem (TableName text, InsKey out text, ObjClass text, AgentName text, ItemStatus text, ProcessingNodeId text, PreviousInsKey text, LastExecutionDateTime timestamp) FROM PUBLIC;



--
-- $Id: sppr_sys_reservequeueitem_b.sql 9596 2011-03-23 19:33:50Z RobReece $
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppr_sys_reservequeueitem_b
--
-- Reserve the next available queue item that matches the criteria.  If
-- ProcessingNodeId is null, then just select the next available
-- item without locking it.
--
-- Date			Who		RuleProID	Description of Modification
-- 27-Aug-09	MiraT	Task-16023	Eliminate commits, use pzInsKey as order by again 
-- 02-Jul-09	MiraT	Task-13095	Use pyMinimumDateTimeForProcessing as order by
-- 21-Jan-09	MiraT	Bug-4274	Cloned from sppr_sys_reservequeueitem
--
   
CREATE OR REPLACE FUNCTION pbs_data.sppr_sys_reservequeueitem_b (TableName text, ObjClass text, AgentName text, ItemStatus text, ProcessingNodeId text, PreviousInsKey text, LastExecutionDateTime timestamp, UseUpperCreateBoundary text, SkipSorting text, InsKey out text) AS $body$
DECLARE

    stmt varchar(4000);
    selCriteria varchar(50);
    selValue varchar(1000);
    selInsKey  varchar(1000);
    potentialInsKey varchar(1000);
    PrevSelCrit varchar(100);
    orderby varchar(128);
    lockhandle varchar(32);
    lockvalue numeric;

    insKeyCurVar REFCURSOR;

    
    
    

BEGIN
    IF AgentName is NOT null THEN
        selCriteria := 'pyAgentName = ';
        selValue := AgentName;
    ELSE
        selCriteria := 'pxObjClass = ';
        selValue := ObjClass;
    END IF;

    IF PreviousInsKey IS NOT NULL THEN
        PrevSelCrit := ' and pySelectId > :4 ';
    ELSE
        PrevSelCrit := ' ';
    END IF;

    orderby := ' order by pzInsKey ASC';

    stmt := 'select pzInskey from (Select pzInskey from ' || TableName ||
            ' where pyItemStatus = :1 and ' || selCriteria || ' :2 ' ||
            ' and pyMinimumDateTimeForProcessing <= :3 ' || PrevSelCrit || orderby || ') ';

    IF ProcessingNodeId IS NOT NULL THEN
    BEGIN

        stmt := stmt || ' where rownum <= 10';
        IF PreviousInsKey IS NOT NULL THEN
            open insKeyCurVar FOR EXECUTE stmt USING ItemStatus, selValue,  LastExecutionDateTime, PreviousInsKey;
        ELSE
            open insKeyCurVar FOR EXECUTE stmt USING ItemStatus, selValue,  LastExecutionDateTime;
        END IF;

		-- at this point we have up to 10 inskeys which we can attempt to lock
		-- any given key will be in one of three states:
		--	1. The key is present and not locked, in which case it will be ours to process
		--	2. The key is present, but locked by another user.  We'll just skip it and try the next one.
		--	3. The key is not even there anymore.  This means another process reserved the item, processed it and deleted it.
        loop
            begin
                fetch insKeyCurVar into potentialInsKey;
                if insKeyCurVar%notfound then
                    exit;
                end if;
                stmt := 'select pzInsKey from ' ||  TableName || ' where pzInsKey = :1 and pyItemStatus = :2 for update nowait';
                EXECUTE stmt into STRICT selInsKey using potentialInsKey, ItemStatus;
                exit; -- we got our key
                exception
                     -- somebody else has this key
                    when nowait_lock
                        then null;
                    when NO_DATA_FOUND then -- somebody else already processed the key and deleted it
                        null;
            end;
        end loop;

       if selinskey IS NOT NULL THEN
           stmt := 'Update ' || TableName || ' SET PXPROCESSINGNODEID = :1, ' ||
                   ' pyItemStatus = ''Now-Processing'',  pxLastExecutionDateTime ' ||
                   '= :2 where pzInsKey = :3';
           EXECUTE stmt using ProcessingNodeId, LastExecutionDateTime, selInsKey;
           InsKey := selInsKey;
           commit;
        else
           InsKey := null;
        end if;
        close insKeyCurVar;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
          InsKey := null;
          ROLLBACK;
          RETURN;
        WHEN SQLSTATE '50001' THEN
          InsKey := null;
          RETURN;
        WHEN SQLSTATE '50002' THEN
          InsKey := null;
          ROLLBACK;
          RETURN;
        WHEN OTHERS THEN
          InsKey := null;
          ROLLBACK;
          RAISE;
    END;

  ELSE
    stmt := stmt || ' where rownum = 1 ';

    BEGIN
        IF PreviousInsKey IS NOT NULL THEN
            EXECUTE stmt INTO STRICT InsKey USING ItemStatus, selValue, LastExecutionDateTime, PreviousInsKey;
        ELSE
            EXECUTE stmt INTO STRICT InsKey USING ItemStatus, selValue, LastExecutionDateTime;
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
          InsKey := NULL;
        WHEN OTHERS THEN
          InsKey := NULL;
          RAISE;
    END;
  END IF;

END;
$body$
LANGUAGE PLPGSQL
;
-- REVOKE ALL ON FUNCTION pbs_data.sppr_sys_reservequeueitem_b (TableName text, ObjClass text, AgentName text, ItemStatus text, ProcessingNodeId text, PreviousInsKey text, LastExecutionDateTime timestamp, UseUpperCreateBoundary text, SkipSorting text, InsKey out text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION pbs_data.sppr_sys_statusnodes_set ( Status text, SystemName text, NodeName text, NodeID text, CodesetsList text, AsmCacheCfgID text) RETURNS VOID AS $body$
DECLARE


--
-- $Id: sppr_sys_statusnodes_set.sql,v 1.6 2007/09/13 23:37:37 dsila Exp $
--
-- Copyright (c) 2010  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppr_sys_statusnodes_set
--
-- Updates the status of the given node in the statusnodes table.
--
-- Date			Who		RuleProID   Description of Modification
-- 16-Mar-10	Dsila	Bug-8576	Remove unecessary commit
-- 26-Feb-10    clinb	BUG-21996 	add codesetslist and cacheconfigid parameters to update new columns
-- 26-May-06	dassu	B-20573 	do not update pyLastIndexBuildDateTime during node restart
-- 05-May-06	dassu	C-2642		initialize pyLastIndexBuildDateTime during node startup
-- 14-Mar-06    KEISE   R-19889     Increase NodeID, NodeName, SystemName to 64 
-- 18-Feb-05	FITZI	B-12436		Make SP field lengths match table
--									column lengths. Make SP field names
--									more closely match column names. Add
--									additional exception handling.
-- 09-Jan-03    CLINB           R-7017
-- 07-Aug-02    frohr           make end statement consistent
-- 06-Aug-02    GajnJ                   Add Node ID to InsName
-- 30-Jul-02	GajnJ			Initial Work
--
/* 
 * This Procedure performs the following operations:
 * If (Status = 'start')
 *    Create An Entry If One Doesn't Exists or Update an Existing one
 * Else if (Status = 'stop')
 *    Update existing entry
 * If there are any problems, we just terminate.
 */
SPpxInsName varchar(128);
SPpxObjClass varchar(96);
SPpyNodeName varchar(64);
SPpySysNodeID varchar(64);
SPpyCodesetsList varchar(700);
SPpySystemName varchar(64);
SPpzInsKey varchar(255);
SPtbl_pxInsName varchar(128);
SPpzAsmCacheCfgID varchar(64);
SPquantum timestamp;


BEGIN

SPpxInsName := upper(SystemName) || '!' || upper(NodeName) || '!' || upper(NodeID);
SPpxObjClass := 'System-Status-Nodes';
SPpySysNodeID := upper(NodeID);
SPpyCodesetsList := CodesetsList;
SPpyNodeName := lower(NodeName);
SPpySystemName := lower(SystemName);
SPpzInsKey := upper(SPpxObjClass) || ' ' || SPpxInsName;
SPquantum := clock_timestamp();
SPpzAsmCacheCfgID := AsmCacheCfgID;

begin
  select pxInsName into STRICT SPtbl_pxInsName from PBS_DATA.pr_sys_statusnodes where pxInsName = SPpxInsName;
exception
  when NO_DATA_FOUND
    then
      /* Expected condition if this is a new node */
      SPtbl_pxInsName := null;
  when OTHERS
    then
      /* Unknown error - trap it and exit */
      RAISE EXCEPTION '%', 'Unknown exception caught during select from pr_sys_statusnodes using pxInsName: ' || SPpxInsName || '	Message: ' || SQLERRM USING ERRCODE = '45001';
end;

if (Status = 'start') then
    /* Check to see if we exist already */
    if (SPtbl_pxInsName is NULL) then
        /* We don't exist. Add a new entry */
        insert into PBS_DATA.pr_sys_statusnodes(pxCreateDateTime, pxInsName, pxObjClass, pxUpdateDateTime, pyCleanShutdown, pyLastIndexBuildDateTime, pyLastPulseDateTime, pyNodeName, pyShutdownNow, pyStartedDateTime, pyStoppedDateTime, pySystemName, pySysNodeId, pzInsKey, pyCodesetsList, pzAsmCacheConfigID)
             values (SPquantum, SPpxInsName, SPpxObjClass, SPquantum, 'false', SPquantum, SPquantum, SPpyNodeName, 'false', SPquantum, NULL, SPpySystemName, SPpySysNodeID, SPpzInsKey, SPpyCodesetsList, SPpzAsmCacheCfgID);
    else
        /* We do exist. Update our entry. */
        update PBS_DATA.pr_sys_statusnodes
             set pxUpdateDateTime = SPquantum,
                 pyCleanShutdown = 'false',
                 pyLastPulseDateTime = SPquantum,
                 pyShutdownNow = 'false',
                 pyStartedDateTime = SPquantum,
                 pyStoppedDateTime  = NULL,
                 pyCodesetsList = SPpyCodesetsList,
                 pzAsmCacheConfigID = SPpzAsmCacheCfgID
             where
                 pxInsName = SPpxInsName;
  end if;
else
  if (Status = 'stop') then
      /*
       * First, a quick sanity check. Our tbl_pxInsName should exist, but
       * if it doesn't, quit. No sense in giving the database a headache.
       */
      if (SPtbl_pxInsName is NULL) then
        return;
      else
          /* We're shutting down. */
          update PBS_DATA.pr_sys_statusnodes
               set pxUpdateDateTime = SPquantum,
                   pyCleanShutdown = 'true',
                   pyShutdownNow = 'true',
                   pyStoppedDateTime = SPquantum
               where
                   pxInsName = SPpxInsName;
       end if;
  else
    return;
  end if;
end if;


end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pbs_data.sppr_sys_statusnodes_set ( Status text, SystemName text, NodeName text, NodeID text, CodesetsList text, AsmCacheCfgID text) FROM PUBLIC;



CREATE OR REPLACE FUNCTION pbs_data.sppr_sys_updatescache_flush (delta_input numeric /* this value should be a positive integer */
) RETURNS VOID AS $body$
DECLARE


--
-- $Id: sppr_sys_updatescache_flush.sql,v 1.4 2007/09/13 23:37:37 dsila Exp $
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppr_sys_updatecache_flush
--
-- Remove entries from the updates cache older than delta_input 
-- minutes.
--
-- Date		    Who	    RuleProID   Description of Modification
-- 16-Mar-10	Dsila	Bug-8576	Remove unecessary commit
-- 30-Jul-02	GajnJ				Initial Work
--
currentDT timestamp;
deltaDT timestamp;


BEGIN

currentDT := clock_timestamp();
deltaDT := currentDT - (delta_input / (24 * 60));

delete from PBS_DATA.pr_sys_updatescache where pzCreateDateTime < deltaDT;



end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pbs_data.sppr_sys_updatescache_flush (delta_input numeric  ) FROM PUBLIC;



--
-- $Id: sppr_sys_updatescache_gettime.sql,v 1.4 2007/09/13 23:37:37 dsila Exp $
--
-- Copyright (c) 2003  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: sppr_sys_updatecache_gettime
--
-- Returns the last pulse time and the current database time
--
-- Date			Who		RuleProID	Description of Modification
-- 12-Aug-03	ChauD	R-9929		Initial coding to let engine generate
--									pulse queries instead of using temp tables,
--									obsoletes prepare and finalize stored procs.
--
 
CREATE OR REPLACE FUNCTION pbs_data.sppr_sys_updatescache_gettime (SPlastPulseTime out timestamp, SPcurrentTime out timestamp, SPnodePZInsKey text) AS $body$
BEGIN
	select min(pyLastPulseDateTime) into STRICT SPlastPulseTime
		from PBS_DATA.pr_sys_statusnodes where pzInsKey = SPnodePZInsKey;
	SPlastPulseTime := coalesce(SPlastPulseTime, to_date('19700101', 'yyyymmdd'));
	SPcurrentTime := clock_timestamp();
end;
$body$
LANGUAGE PLPGSQL
;
-- REVOKE ALL ON FUNCTION pbs_data.sppr_sys_updatescache_gettime (SPlastPulseTime out timestamp, SPcurrentTime out timestamp, SPnodePZInsKey text) FROM PUBLIC;


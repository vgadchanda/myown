-- Generated by Ora2Pg, the Oracle database Schema converter, version 19.1
-- Copyright 2000-2018 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=localhost;sid=orcl;port=1521

SET client_encoding TO 'UTF8';

SET search_path = pbs_rules;
\set ON_ERROR_STOP ON

DROP TRIGGER IF EXISTS trpr4_base ON pr4_base CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_base() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_base
--
-- Trigger to gather all updates to the pr_base table.
--
-- Date         Who     RuleProID       Description of Modification
-- 14-Oct-08	ErnsG	Task-3242		change params var to 160 len
-- 14-Oct-08	ErnsG	Task-3242		workaround ampersand syntax in SQL Plus
-- 10-Oct-08	ErnsG	Task-3242		add ruleset to params
-- 09-Jul-07	rajusr	SCH-88			supply value(true/false) for pzParameters column
-- 02-Feb-04	Lawtt	r-12309			Use available Nodename from rule record.
-- 18-Dec-03	SchuD					Create or replace for upgrade
-- 31-Jul-02    GajnJ                   Unify ClearType across all triggers
-- 30-Jul-02    GajnJ                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);

validTrigger	 boolean;

BEGIN

validTrigger := false;

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT'  then
	validTrigger := true;
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet;
elsif TG_OP = 'UPDATE' then
	validTrigger := true;
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet;
elsif TG_OP = 'DELETE' then
	validTrigger := true;
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
if 	validTrigger then
	insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
	      pzCreateDateTime,
	      pzClearCacheType,
	      pzNodeName,
	      pzSystemName,
	      pzObjClass,
	      pzParameters)
	values (SPtpzInsKey,
	      LOCALTIMESTAMP,
	      'Cache',
	      SPtpxNodeName,
	      SPtpxSystemName,
	      SPtpzObjClass,
	      SPtpzParameters);
	
	/* commit; */
end if;

IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_base() FROM PUBLIC;

CREATE TRIGGER trpr4_base
	AFTER INSERT OR UPDATE OR DELETE ON pr4_base FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_base();

DROP TRIGGER IF EXISTS trpr4_base_vw_del ON pr4_base CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_base_vw_del() RETURNS trigger AS $BODY$
declare
SPtpzInsKey 	varchar(255);
BEGIN
if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;
delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_base_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_base_vw_del
	AFTER DELETE ON pr4_base FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_base_vw_del();

DROP TRIGGER IF EXISTS trpr4_base_vw_upd ON pr4_base CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_base_vw_upd() RETURNS trigger AS $BODY$
declare

SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyLabel varchar(64);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
SPtpxCreateDateTime timestamp;
v_dummy bigint;
v_minorpatch varchar(5);


BEGIN

if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey:= NEW.pzInsKey;
    	SPtpxInsId:= NEW.pxInsId;
    	SPtpxInsName:= NEW.pxInsName;
    	SPtpxUpdateDateTime:= NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator:= NEW.pxUpdateOperator;
    	SPtpxUpdateOpName:= NEW.pxUpdateOpName;
    	SPtpyClassName:= NEW.pyClassName;
    	SPtpzObjClasspw:= NEW.pxObjClass;
    	SPtpyCircumstanceDate:= NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp:= NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp:= NEW.pyCircumstanceProp;
	SPtpyCircumstanceType:= NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal:= NEW.pyCircumstanceVal;
    	SPtpyLabel:= NEW.pyLabel;
    	SPtpyRuleAvailable:= NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet:= NEW.pyRuleSet;
    	SPtpyRuleSetVersion:= NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts:= NEW.pyRuleStarts;
    	SPtpyRuleEnds:= NEW.pyRuleEnds;

end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;

	    IF SPtpzInsKey LIKE 'RULE-%' THEN
        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator ,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
            			    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyLabel = SPtpyLabel,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
				    pzClassType = 2
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId ,
				    pxInsName ,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyLabel,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
				    pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyLabel,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
				    SPtpzRuleSetVersionMajor,
				    SPtpzRuleSetVersionMinor,
				    SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					2
				);



		end if;
		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_base_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_base_vw_upd 
 AFTER INSERT OR UPDATE ON "pbs_rules"."pr4_base" FOR EACH ROW
	WHEN (new.pzInsKey like 'RULE-%')
	EXECUTE PROCEDURE trigger_fct_trpr4_base_vw_upd();

DROP TRIGGER IF EXISTS trpr4_fieldvalue ON pr4_fieldvalue CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_fieldvalue() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_fieldvalue
--
-- Trigger to gather the updates to the pr_fieldvalue table
--
-- Date	        Who     RuleProID       Description of Modification
-- 17-Sep-09	OexnJ	GRP-7459		Add pxInstanceLockedBy to pzParameters
-- 14-Oct-08	ErnsG	Task-3242		change params var to 160 len
-- 14-Oct-08	ErnsG	Task-3242		workaround ampersand syntax in SQL Plus
-- 10-Oct-08	ErnsG	Task-3242		add ruleset to params
-- 09-Jul-07	rajusr	SCH-88			supply value(true/false) for pzParameters column
-- 02-Feb-04	Lawtt	r-12309			Use available Nodename from rule record.
-- 18-Dec-03	SchuD					Create or replace for upgrade
-- 31-Jul-02    GajnJ                   Unify ClearType across triggers
-- 30-Jul-02    GajnJ                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);
SPtpxInstanceLockedBy	varchar(128);

BEGIN

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
elsif TG_OP = 'UPDATE' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
else
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
      pzCreateDateTime,
      pzClearCacheType,
      pzNodeName,
      pzSystemName,
      pzObjClass,
	  pzParameters)
values (SPtpzInsKey,
      LOCALTIMESTAMP,
      'Cache',
      SPtpxNodeName,
      SPtpxSystemName,
      SPtpzObjClass,
	  SPtpzParameters);
	
/* commit; */
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_fieldvalue() FROM PUBLIC;

CREATE TRIGGER trpr4_fieldvalue
	AFTER INSERT OR UPDATE OR DELETE ON pr4_fieldvalue FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_fieldvalue();

DROP TRIGGER IF EXISTS trpr4_field_vw_del ON pr4_fieldvalue CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_field_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(255);

BEGIN

if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;

delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
	
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_field_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_field_vw_del
	AFTER DELETE ON pr4_fieldvalue FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_field_vw_del();

DROP TRIGGER IF EXISTS trpr4_field_vw_upd ON pr4_fieldvalue CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_field_vw_upd() RETURNS trigger AS $BODY$
declare


SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxInstanceLockedKey varchar(255);
SPtpxMergeSynchronized timestamp;
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyInterface varchar(64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution  varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	SPtpyInterface := NEW.pyInterface;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
        SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	
	SELECT pyClassInheritance,
	pyRuleResolution 
	into STRICT v_classinheritance, 
        v_ruleresolution
	FROM PBS_RULES.pr4_base 
	WHERE pyClassName = SPtpzObjClasspw 
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;
	
	if v_classinheritance='true' and v_ruleresolution='true' then
		SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
		SptpzClassType :=1;
        elsif  v_classinheritance='false' and v_ruleresolution='false' then
		SptpzClassType :=2;
	end if;
	

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator ,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
				    pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
				    pzClassType = SPtpzClassType
				    where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId ,
				    pxInsName ,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator ,
				    pxUpdateOpName ,
				    pyClass ,
				    pyClassName ,
				    pyCircumstanceDate ,
				    pyCircumstanceDateProp ,
				    pyCircumstanceProp ,
				    pyCircumstanceType,
				    pyCircumstanceVal ,
				    pyInterface,
				    pyLabel ,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
                    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,                    		
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
				    pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyInterface,
					SPtpyLabel,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
                    SPtpxInstanceLockedBy,
				    SPtpzRuleSetVersionMajor,
				    SPtpzRuleSetVersionMinor,
				    SPtpzRuleSetVersionPatch,
				    v_minorpatch,
				    SPtpzInsKey,
				    SptpzClassType
				);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_field_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_field_vw_upd
	AFTER INSERT OR UPDATE ON pr4_fieldvalue FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_field_vw_upd();

DROP TRIGGER IF EXISTS trpr4_file_binary_vw_del ON pr4_rule_file_binary CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_file_binary_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(255);

BEGIN

if TG_OP = 'DELETE' then
 	SPtpzInsKey := OLD.pzInsKey;
end if;

delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
	
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_file_binary_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_file_binary_vw_del
	AFTER DELETE ON pr4_rule_file_binary FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_file_binary_vw_del();

DROP TRIGGER IF EXISTS trpr4_file_binary_vw_upd ON pr4_rule_file_binary CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_file_binary_vw_upd() RETURNS trigger AS $BODY$
declare


SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxInstanceLockedKey varchar(255);
SPtpxNodeName 	varchar(32);
SPtpxMergeSynchronized timestamp;
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyInterface varchar(64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy  varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	SPtpyInterface := NEW.pyInterface;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
        SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
                    		    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator ,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
            		pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId ,
				    pxInsName ,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator ,
				    pxUpdateOpName ,
				    pyClass ,
				    pyClassName ,
				    pyCircumstanceDate ,
				    pyCircumstanceDateProp ,
				    pyCircumstanceProp ,
				    pyCircumstanceType,
				    pyCircumstanceVal ,
				    pyInterface,
				    pyLabel ,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
                    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SptpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyInterface,
					SPtpyLabel,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
          			SPtpxInstanceLockedBy,
				    SPtpzRuleSetVersionMajor,
				    SPtpzRuleSetVersionMinor,
				    SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpzClassType
					);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_file_binary_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_file_binary_vw_upd
	AFTER INSERT OR UPDATE ON pr4_rule_file_binary FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_file_binary_vw_upd();

DROP TRIGGER IF EXISTS trpr4_file_vw_del ON pr4_rule_file CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_file_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(255);

BEGIN

if TG_OP = 'DELETE' then
 	SPtpzInsKey := OLD.pzInsKey;
end if;

delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
	
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_file_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_file_vw_del
	AFTER DELETE ON pr4_rule_file FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_file_vw_del();

DROP TRIGGER IF EXISTS trpr4_file_vw_upd ON pr4_rule_file CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_file_vw_upd() RETURNS trigger AS $BODY$
declare


SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxInstanceLockedKey varchar(255);
SPtpxMergeSynchronized timestamp;
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyInterface varchar(64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy  varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	SPtpyInterface := NEW.pyInterface;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
        SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
                    		    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator ,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
            		pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId ,
				    pxInsName ,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator ,
				    pxUpdateOpName ,
				    pyClass ,
				    pyClassName ,
				    pyCircumstanceDate ,
				    pyCircumstanceDateProp ,
				    pyCircumstanceProp ,
				    pyCircumstanceType,
				    pyCircumstanceVal ,
				    pyInterface,
				    pyLabel ,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
                    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SptpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyInterface,
					SPtpyLabel,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
          			SPtpxInstanceLockedBy,
				    SPtpzRuleSetVersionMajor,
				    SPtpzRuleSetVersionMinor,
				    SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpzClassType);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_file_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_file_vw_upd
	AFTER INSERT OR UPDATE ON pr4_rule_file FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_file_vw_upd();

DROP TRIGGER IF EXISTS trpr4_flow_vw_del ON pr4_rule_flow CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_flow_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(255);

BEGIN

if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;
	
delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;

RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_flow_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_flow_vw_del
	AFTER DELETE ON pr4_rule_flow FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_flow_vw_del();

DROP TRIGGER IF EXISTS trpr4_flow_vw_upd ON pr4_rule_flow CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_flow_vw_upd() RETURNS trigger AS $BODY$
declare


SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxInstanceLockedKey varchar(255);
SPtpxMergeSynchronized timestamp;
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyInterface varchar(64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	SPtpyInterface := NEW.pyInterface;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
        SPtpxInstanceLockedBy  := NEW.pxInstanceLockedBy;

end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator ,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
                    		    pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId,
				    pxInsName,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyInterface,
				    pyLabel,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
                    		    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyInterface,
					SPtpyLabel ,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet ,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
	        			SPtpxInstanceLockedBy,
				    	SPtpzRuleSetVersionMajor,
				    	SPtpzRuleSetVersionMinor,
				    	SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpzClassType);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_flow_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_flow_vw_upd
	AFTER INSERT OR UPDATE ON pr4_rule_flow FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_flow_vw_upd();

DROP TRIGGER IF EXISTS trpr4_rdp ON pr4_rule_declarepages CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rdp() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_rule_prop
--
-- Trigger to gather updates to the pr_rule table
--
-- Date	        Who     RuleProID       Description of Modification
-- 17-Sep-09	OexnJ	GRP-7459		Add pxInstanceLockedBy to pzParameters
-- 14-Oct-08	ErnsG	Task-3242		change params var to 160 len
-- 14-Oct-08	ErnsG	Task-3242		workaround ampersand syntax in SQL Plus
-- 10-Oct-08	ErnsG	Task-3242		add ruleset to params
-- 09-Jul-07	rajusr	SCH-88			supply value(true/false) for pzParameters column
-- 02-Feb-04	Lawtt	r-12309			Use available Nodename from rule record.
-- 18-Dec-03	SchuD					Create or replace for upgrade
-- 31-Jul-02    GajnJ                   Unify ClearType across triggers
-- 30-Jul-02    GajnJ                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);
SPtpxInstanceLockedBy	varchar(128);

BEGIN

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
elsif TG_OP = 'UPDATE' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
else
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
      pzCreateDateTime,
      pzClearCacheType,
      pzNodeName,
      pzSystemName,
      pzObjClass,
	  pzParameters)
values (SPtpzInsKey,
      LOCALTIMESTAMP,
      'Cache',
      SPtpxNodeName,
      SPtpxSystemName,
      SPtpzObjClass,
	  SPtpzParameters);
	
/* commit; */
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rdp() FROM PUBLIC;

CREATE TRIGGER trpr4_rdp
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule_declarepages FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rdp();

DROP TRIGGER IF EXISTS trpr4_rdp_vw_del ON pr4_rule_declarepages CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rdp_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(255);

BEGIN
if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;

delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rdp_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_rdp_vw_del
	AFTER DELETE ON pr4_rule_declarepages FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rdp_vw_del();

DROP TRIGGER IF EXISTS trpr4_rdp_vw_upd ON pr4_rule_declarepages CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rdp_vw_upd() RETURNS trigger AS $BODY$
declare



SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxInstanceLockedKey varchar(255);
SPtpxMergeSynchronized timestamp;
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyInterface varchar(64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	SPtpyInterface := NEW.pyInterface;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
        SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
                    		    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator,
				    pxUpdateOpName = SPtpxUpdateOpName,
                    pyClassName = SPtpyClassName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
	                	    pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId,
				    pxInsName ,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyInterface,
				    pyLabel,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
            			    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,                    		
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyInterface,
					SPtpyLabel,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
          				SPtpxInstanceLockedBy,
				    	SPtpzRuleSetVersionMajor,
				    	SPtpzRuleSetVersionMinor,
				    	SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpzClassType);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rdp_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_rdp_vw_upd
	AFTER INSERT OR UPDATE ON pr4_rule_declarepages FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rdp_vw_upd();

DROP TRIGGER IF EXISTS trpr4_req ON pr4_rule_requirement CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_req() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_base
--
-- Trigger to gather all updates to the pr_base table.
--
-- Date         Who     RuleProID       Description of Modification
-- 14-Oct-08	ErnsG	Task-3242		change params var to 160 len
-- 14-Oct-08	ErnsG	Task-3242		workaround ampersand syntax in SQL Plus
-- 10-Oct-08	ErnsG	Task-3242		add ruleset to params
-- 09-Jul-07	rajusr	SCH-88			supply value(true/false) for pzParameters column
-- 02-Feb-04	Lawtt	r-12309			Use available Nodename from rule record.
-- 18-Dec-03	SchuD					Create or replace for upgrade
-- 31-Jul-02    GajnJ                   Unify ClearType across all triggers
-- 30-Jul-02    GajnJ                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);

validTrigger	 boolean;

BEGIN

validTrigger := false;

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT'  then
	validTrigger := true;
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet;
elsif TG_OP = 'UPDATE' then
	validTrigger := true;
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet;
elsif TG_OP = 'DELETE' then
	validTrigger := true;
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
if 	validTrigger then
	insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
	      pzCreateDateTime,
	      pzClearCacheType,
	      pzNodeName,
	      pzSystemName,
	      pzObjClass,
	      pzParameters)
	values (SPtpzInsKey,
	      LOCALTIMESTAMP,
	      'Cache',
	      SPtpxNodeName,
	      SPtpxSystemName,
	      SPtpzObjClass,
	      SPtpzParameters);
	
	/* commit; */
end if;

IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_req() FROM PUBLIC;

CREATE TRIGGER trpr4_req
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule_requirement FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_req();

DROP TRIGGER IF EXISTS trpr4_req_vw_del ON pr4_rule_requirement CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_req_vw_del() RETURNS trigger AS $BODY$
declare
SPtpzInsKey 	varchar(255);
BEGIN
if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;
delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_req_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_req_vw_del
	AFTER DELETE ON pr4_rule_requirement FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_req_vw_del();

DROP TRIGGER IF EXISTS trpr4_req_vw_upd ON pr4_rule_requirement CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_req_vw_upd() RETURNS trigger AS $BODY$
declare

SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxMergeSynchronized timestamp;
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyLabel varchar(64);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
SPtpxCreateDateTime timestamp;
SPtpyMethodStatus varchar(32);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN

if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey:= NEW.pzInsKey;
    	SPtpxInsId:= NEW.pxInsId;
    	SPtpxInsName:= NEW.pxInsName;
    	SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateDateTime:= NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator:= NEW.pxUpdateOperator;
    	SPtpxUpdateOpName:= NEW.pxUpdateOpName;
    	SPtpyClassName:= NEW.pyClassName;
    	SPtpzObjClasspw:= NEW.pxObjClass;
    	SPtpyCircumstanceDate:= NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp:= NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp:= NEW.pyCircumstanceProp;
	SPtpyCircumstanceType:= NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal:= NEW.pyCircumstanceVal;
    	SPtpyLabel:= NEW.pyLabel;
    	SPtpyRuleAvailable:= NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet:= NEW.pyRuleSet;
    	SPtpyRuleSetVersion:= NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts:= NEW.pyRuleStarts;
    	SPtpyRuleEnds:= NEW.pyRuleEnds;
    	SPtpyMethodStatus := NEW.pyMethodStatus;

end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

	    IF SPtpzInsKey LIKE 'RULE-%' THEN
        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				 	pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator ,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
            			    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyLabel = SPtpyLabel,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
				    pyMethodStatus = SPtpyMethodStatus,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId ,
				    pxInsName ,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyLabel,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
				    pyMethodStatus,
				    pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyLabel,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
				    SPtpzRuleSetVersionMajor,
				    SPtpzRuleSetVersionMinor,
				    SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpyMethodStatus,
					SPtpzClassType
				);



		end if;
		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_req_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_req_vw_upd 
AFTER INSERT OR UPDATE ON "pbs_rules"."pr4_rule_requirement" FOR EACH ROW
	WHEN (new.pzInsKey like 'RULE-%')
	EXECUTE PROCEDURE trigger_fct_trpr4_req_vw_upd();

DROP TRIGGER IF EXISTS trpr4_rrs ON pr4_rule_ruleset CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rrs() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_base
--
-- Trigger to gather all updates to the pr_base table.
--
-- Date         Who     RuleProID       Description of Modification
-- 14-Oct-08	ErnsG	Task-3242		change params var to 160 len
-- 14-Oct-08	ErnsG	Task-3242		workaround ampersand syntax in SQL Plus
-- 10-Oct-08	ErnsG	Task-3242		add ruleset to params
-- 09-Jul-07	rajusr	SCH-88			supply value(true/false) for pzParameters column
-- 02-Feb-04	Lawtt	r-12309			Use available Nodename from rule record.
-- 18-Dec-03	SchuD					Create or replace for upgrade
-- 31-Jul-02    GajnJ                   Unify ClearType across all triggers
-- 30-Jul-02    GajnJ                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);

validTrigger	 boolean;

BEGIN

validTrigger := false;

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT'  then
	validTrigger := true;
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet;
elsif TG_OP = 'UPDATE' then
	validTrigger := true;
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet;
elsif TG_OP = 'DELETE' then
	validTrigger := true;
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
if 	validTrigger then
	insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
	      pzCreateDateTime,
	      pzClearCacheType,
	      pzNodeName,
	      pzSystemName,
	      pzObjClass,
	      pzParameters)
	values (SPtpzInsKey,
	      LOCALTIMESTAMP,
	      'Cache',
	      SPtpxNodeName,
	      SPtpxSystemName,
	      SPtpzObjClass,
	      SPtpzParameters);
	
	/* commit; */
end if;

IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rrs() FROM PUBLIC;

CREATE TRIGGER trpr4_rrs
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule_ruleset FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rrs();

DROP TRIGGER IF EXISTS trpr4_rrs_vw_del ON pr4_rule_ruleset CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rrs_vw_del() RETURNS trigger AS $BODY$
declare
SPtpzInsKey 	varchar(255);
BEGIN
if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;
delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rrs_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_rrs_vw_del
	AFTER DELETE ON pr4_rule_ruleset FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rrs_vw_del();

DROP TRIGGER IF EXISTS trpr4_rrs_vw_upd ON pr4_rule_ruleset CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rrs_vw_upd() RETURNS trigger AS $BODY$
declare

SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyLabel varchar(64);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
SPtpxCreateDateTime timestamp;
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);


BEGIN

if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey:= NEW.pzInsKey;
    	SPtpxInsId:= NEW.pxInsId;
    	SPtpxInsName:= NEW.pxInsName;
    	SPtpxUpdateDateTime:= NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator:= NEW.pxUpdateOperator;
    	SPtpxUpdateOpName:= NEW.pxUpdateOpName;
    	SPtpyClassName:= null;
    	SPtpzObjClasspw:= NEW.pxObjClass;
    	SPtpyCircumstanceDate:= null;
    	SPtpyCircumstanceDateProp:= null;
    	SPtpyCircumstanceProp:= null;
	SPtpyCircumstanceType:= null;
    	SPtpyCircumstanceVal:= null;
    	SPtpyLabel:= NEW.pyLabel;
    	SPtpyRuleAvailable:= null;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet:= NEW.pyRuleSet;
    	SPtpyRuleSetVersion:= null;
    	SPtpzRuleSetVersionMajor:= -1;
    	SPtpzRuleSetVersionMinor:= -1;
    	SPtpzRuleSetVersionPatch:= -1;
    	SPtpyRuleStarts:= null;
    	SPtpyRuleEnds:= null;

end if;
	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator ,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
            			    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyLabel = SPtpyLabel,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = '-1',
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId ,
				    pxInsName ,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyLabel,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					null,
					null,
					null,
					null,
					null,
					null,
					SPtpyLabel,
					null,
					SPtpyRuleName,
					SPtpyRuleSet,
					null,
					null,
					null,
				    -1,
				    -1,
				    -1,
				    '-1',
					SPtpzInsKey,
					SPtpzClassType);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rrs_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_rrs_vw_upd 
AFTER INSERT OR UPDATE ON "pbs_rules"."pr4_rule_ruleset" FOR EACH ROW
	WHEN (new.pzInsKey like 'RULE-%')
	EXECUTE PROCEDURE trigger_fct_trpr4_rrs_vw_upd();

DROP TRIGGER IF EXISTS trpr4_rule ON pr4_rule CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_rule
--
-- Trigger to gather updates to the pr_rule table
--
-- Date	        Who     RuleProID       Description of Modification
-- 17-Oct-09	BlacE	BUG-14873		Fix bug in delete, SPtpxNodeName := :new.pxHostId; should be :old.
-- 17-Sep-09	OexnJ	GRP-7459		Add pxInstanceLockedBy to pzParameters
-- 14-Oct-08	ErnsG	Task-3242		change params var to 160 len
-- 14-Oct-08	ErnsG	Task-3242		workaround ampersand syntax in SQL Plus
-- 10-Oct-08	ErnsG	Task-3242		add ruleset to params
-- 09-Jul-07	rajusr	SCH-88			supply value(true/false) for pzParameters column
-- 02-Feb-04	Lawtt	r-12309			Use available Nodename from rule record.
-- 18-Dec-03	SchuD					Create or replace for upgrade
-- 31-Jul-02    GajnJ                   Unify ClearType across triggers
-- 30-Jul-02    GajnJ                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);
SPtpxInstanceLockedBy	varchar(128);

BEGIN

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
elsif TG_OP = 'UPDATE' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
else
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := null;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
      pzCreateDateTime,
      pzClearCacheType,
      pzNodeName,
      pzSystemName,
      pzObjClass,
	  pzParameters)
values (SPtpzInsKey,
      LOCALTIMESTAMP,
      'Cache',
      SPtpxNodeName,
      SPtpxSystemName,
      SPtpzObjClass,
	  SPtpzParameters);
	
/* commit; */
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule() FROM PUBLIC;

CREATE TRIGGER trpr4_rule
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule();

DROP TRIGGER IF EXISTS trpr4_rule_autotest ON pr4_rule_autotest CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_autotest() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_rule_autotest
--
-- Trigger to gather updates to the pr_rule table
--
-- Date	        Who     RuleProID       Description of Modification
-- 24-Feb-10    bobbv                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);
SPtpxInstanceLockedBy	varchar(128);

BEGIN

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
elsif TG_OP = 'UPDATE' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
else
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
      pzCreateDateTime,
      pzClearCacheType,
      pzNodeName,
      pzSystemName,
      pzObjClass,
	  pzParameters)
values (SPtpzInsKey,
      LOCALTIMESTAMP,
      'Cache',
      SPtpxNodeName,
      SPtpxSystemName,
      SPtpzObjClass,
	  SPtpzParameters);
	
/* commit; */
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_autotest() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_autotest
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule_autotest FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_autotest();

DROP TRIGGER IF EXISTS trpr4_rule_autotest_vw_del ON pr4_rule_autotest CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_autotest_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(255);

BEGIN

if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;

delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
	
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_autotest_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_autotest_vw_del
	AFTER DELETE ON pr4_rule_autotest FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_autotest_vw_del();

DROP TRIGGER IF EXISTS trpr4_rule_autotest_vw_upd ON pr4_rule_autotest CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_autotest_vw_upd() RETURNS trigger AS $BODY$
declare



SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxInstanceLockedKey varchar(255);
SPtpxMergeSynchronized timestamp;
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyInterface varchar(64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
        SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	SPtpyInterface := NULL;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
      	SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
			            pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId,
				    pxInsName,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp ,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyInterface,
				    pyLabel,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
                    		    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,                    		
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyInterface,
					SPtpyLabel,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
                    			SPtpxInstanceLockedBy,
				    	SPtpzRuleSetVersionMajor,
				    	SPtpzRuleSetVersionMinor,
				    	SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpzClassType);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_autotest_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_autotest_vw_upd
	AFTER INSERT OR UPDATE ON pr4_rule_autotest FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_autotest_vw_upd();

DROP TRIGGER IF EXISTS trpr4_rule_flow ON pr4_rule_flow CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_flow() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_rule_flow
--
-- Trigger to gather updates to the pr_rule_flow table
--
-- Date	        Who     RuleProID       Description of Modification
-- 17-Sep-09	OexnJ	GRP-7459		Add pxInstanceLockedBy to pzParameters
-- 14-Oct-08	ErnsG	Task-3242		change params var to 160 len
-- 14-Oct-08	ErnsG	Task-3242		workaround ampersand syntax in SQL Plus
-- 10-Oct-08	ErnsG	Task-3242		add ruleset to params
-- 09-Jul-07	rajusr	SCH-88			supply value(true/false) for pzParameters column
-- 02-Feb-04	Lawtt	r-12309			Use available Nodename from rule record.
-- 18-Dec-03	SchuD					Create or replace for upgrade
-- 31-Jul-02    GajnJ                   Unify ClearType across triggers
-- 30-Jul-02    GajnJ                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);
SPtpxInstanceLockedBy	varchar(128);

BEGIN

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
elsif TG_OP = 'UPDATE' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
else
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
      pzCreateDateTime,
      pzClearCacheType,
      pzNodeName,
      pzSystemName,
      pzObjClass,
	  pzParameters)
values (SPtpzInsKey,
      LOCALTIMESTAMP,
      'Cache',
      SPtpxNodeName,
      SPtpxSystemName,
      SPtpzObjClass,
	  SPtpzParameters);

/* commit; */
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_flow() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_flow
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule_flow FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_flow();

DROP TRIGGER IF EXISTS trpr4_rule_message ON pr4_rule_message CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_message() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_rule_message
--
-- Trigger to gather updates to the pr_rule_message table
--
-- Date	        Who     RuleProID       Description of Modification
-- 24-Feb-10    bobbv                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(315);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);
SPtpxInstanceLockedBy	varchar(128);

BEGIN

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
elsif TG_OP = 'UPDATE' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
else
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
      pzCreateDateTime,
      pzClearCacheType,
      pzNodeName,
      pzSystemName,
      pzObjClass,
	  pzParameters)
values (SPtpzInsKey,
      LOCALTIMESTAMP,
      'Cache',
      SPtpxNodeName,
      SPtpxSystemName,
      SPtpzObjClass,
	  SPtpzParameters);
	
/* commit; */
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_message() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_message
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule_message FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_message();

DROP TRIGGER IF EXISTS trpr4_rule_message_vw_del ON pr4_rule_message CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_message_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(315);

BEGIN

if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;

delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
	
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_message_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_message_vw_del
	AFTER DELETE ON pr4_rule_message FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_message_vw_del();

DROP TRIGGER IF EXISTS trpr4_rule_message_vw_upd ON pr4_rule_message CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_message_vw_upd() RETURNS trigger AS $BODY$
declare



SPtpzInsKey varchar(315);
SPtyzInsKeyVw varchar(315);
SPtpxInstanceLockedKey varchar(255);
SPtpxMergeSynchronized timestamp;
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(315);
SPtpxInsId varchar(128);
SPtpxInsName varchar(193);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyInterface varchar(64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
        SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	SPtpyInterface := NULL;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
      	SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
			            pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId,
				    pxInsName,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp ,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyInterface,
				    pyLabel,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
                    		    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,                    		
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyInterface,
					SPtpyLabel,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
                    			SPtpxInstanceLockedBy,
				    	SPtpzRuleSetVersionMajor,
				    	SPtpzRuleSetVersionMinor,
				    	SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpzClassType);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_message_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_message_vw_upd
	AFTER INSERT OR UPDATE ON pr4_rule_message FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_message_vw_upd();

DROP TRIGGER IF EXISTS trpr4_rule_prop ON pr4_rule_property CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_prop() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_rule_prop
--
-- Trigger to gather updates to the pr_rule table
--
-- Date	        Who     RuleProID       Description of Modification
-- 17-Sep-09	OexnJ	GRP-7459		Add pxInstanceLockedBy to pzParameters
-- 14-Oct-08	ErnsG	Task-3242		change params var to 160 len
-- 14-Oct-08	ErnsG	Task-3242		workaround ampersand syntax in SQL Plus
-- 10-Oct-08	ErnsG	Task-3242		add ruleset to params
-- 09-Jul-07	rajusr	SCH-88			supply value(true/false) for pzParameters column
-- 02-Feb-04	Lawtt	r-12309			Use available Nodename from rule record.
-- 18-Dec-03	SchuD					Create or replace for upgrade
-- 31-Jul-02    GajnJ                   Unify ClearType across triggers
-- 30-Jul-02    GajnJ                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);
SPtpxInstanceLockedBy	varchar(128);

BEGIN

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
elsif TG_OP = 'UPDATE' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
else
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
      pzCreateDateTime,
      pzClearCacheType,
      pzNodeName,
      pzSystemName,
      pzObjClass,
	  pzParameters)
values (SPtpzInsKey,
      LOCALTIMESTAMP,
      'Cache',
      SPtpxNodeName,
      SPtpxSystemName,
      SPtpzObjClass,
	  SPtpzParameters);
	
/* commit; */
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_prop() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_prop
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule_property FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_prop();

DROP TRIGGER IF EXISTS trpr4_rule_prop_vw_del ON pr4_rule_property CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_prop_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(255);

BEGIN
if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;

delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_prop_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_prop_vw_del
	AFTER DELETE ON pr4_rule_property FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_prop_vw_del();

DROP TRIGGER IF EXISTS trpr4_rule_prop_vw_upd ON pr4_rule_property CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_prop_vw_upd() RETURNS trigger AS $BODY$
declare



SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxInstanceLockedKey varchar(255);
SPtpxMergeSynchronized timestamp;
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyInterface varchar(64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	SPtpyInterface := NEW.pyInterface;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
        SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
end if;


if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
                    		    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
	                	    pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId,
				    pxInsName ,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyInterface,
				    pyLabel,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
            			    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,                    		
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyInterface,
					SPtpyLabel,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
          				SPtpxInstanceLockedBy,
				    	SPtpzRuleSetVersionMajor,
				    	SPtpzRuleSetVersionMinor,
				    	SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpzClassType);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_prop_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_prop_vw_upd
	AFTER INSERT OR UPDATE ON pr4_rule_property FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_prop_vw_upd();

DROP TRIGGER IF EXISTS trpr4_rule_shortcut ON pr4_rule_shortcut CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_shortcut() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_rule_shortcut
--
-- Trigger to gather updates to the pr_rule_shortcut table
--
-- Date	        Who     RuleProID       Description of Modification
-- 25-May-10    bobbv                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);
SPtpxInstanceLockedBy	varchar(128);

BEGIN

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
elsif TG_OP = 'UPDATE' then
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet || '&' || 'pxInstanceLockedBy=' || SPtpxInstanceLockedBy;
else
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
      pzCreateDateTime,
      pzClearCacheType,
      pzNodeName,
      pzSystemName,
      pzObjClass,
	  pzParameters)
values (SPtpzInsKey,
      LOCALTIMESTAMP,
      'Cache',
      SPtpxNodeName,
      SPtpxSystemName,
      SPtpzObjClass,
	  SPtpzParameters);
	
/* commit; */
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_shortcut() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_shortcut
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule_shortcut FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_shortcut();

DROP TRIGGER IF EXISTS trpr4_rule_shortcut_vw_del ON pr4_rule_shortcut CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_shortcut_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(255);

BEGIN

if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;

delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
	
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_shortcut_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_shortcut_vw_del
	AFTER DELETE ON pr4_rule_shortcut FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_shortcut_vw_del();

DROP TRIGGER IF EXISTS trpr4_rule_shortcut_vw_upd ON pr4_rule_shortcut CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_shortcut_vw_upd() RETURNS trigger AS $BODY$
declare



SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxInstanceLockedKey varchar(255);
SPtpxMergeSynchronized timestamp;
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
--SPtpyInterface VARCHAR (64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
      	SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	--SPtpyInterface := :new.pyInterface;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor := NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor := NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch := NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
      	SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    --pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
				    pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId,
				    pxInsName,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate ,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    --pyInterface,
				    pyLabel,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
                    		    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,                    		
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          			  	SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					--SPtpyInterface,
					SPtpyLabel,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
                    			SPtpxInstanceLockedBy,
				    	SPtpzRuleSetVersionMajor,
				    	SPtpzRuleSetVersionMinor,
				    	SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpzClassType);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_shortcut_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_shortcut_vw_upd
	AFTER INSERT OR UPDATE ON pr4_rule_shortcut FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_shortcut_vw_upd();

DROP TRIGGER IF EXISTS trpr4_rule_vw_del ON pr4_rule CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_vw_del() RETURNS trigger AS $BODY$
declare

SPtpzInsKey 	varchar(255);

BEGIN

if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;

delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
	
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_vw_del
	AFTER DELETE ON pr4_rule FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_vw_del();

DROP TRIGGER IF EXISTS trpr4_rule_vw_upd ON pr4_rule CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_rule_vw_upd() RETURNS trigger AS $BODY$
declare



SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxInstanceLockedKey varchar(255);
SPtpxNodeName 	varchar(32);
SPtpxMergeSynchronized timestamp;
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxUpdateDateTime timestamp;
SPtpxCreateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(64);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyInterface varchar(64);
SPtpyLabel varchar(64);
SPtpyMethodStatus varchar(32);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN


if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey := NEW.pzInsKey;
    	SPtpxInsId := NEW.pxInsId;
    	SPtpxInsName := NEW.pxInsName;
    	SPtpxInstanceLockedKey := NEW.pxInstanceLockedKey;
    	SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateDateTime := NEW.pxUpdateDateTime;
      	SPtpxCreateDateTime := NEW.pxCreateDateTime;
    	SPtpxUpdateOperator := NEW.pxUpdateOperator;
    	SPtpxUpdateOpName := NEW.pxUpdateOpName;
    	SPtpzObjClasspw := NEW.pxObjClass;
    	SPtpyClassName := NEW.pyClassName;
    	SPtpyCircumstanceDate := NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp := NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp := NEW.pyCircumstanceProp;
    	SPtpyCircumstanceType := NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal := NEW.pyCircumstanceVal;
    	SPtpyInterface := NEW.pyInterface;
    	SPtpyLabel := NEW.pyLabel;
    	SPtpyMethodStatus := NEW.pyMethodStatus;
    	SPtpyRuleAvailable := NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet := NEW.pyRuleSet;
    	SPtpyRuleSetVersion := NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts := NEW.pyRuleStarts;
    	SPtpyRuleEnds := NEW.pyRuleEnds;
      	SPtpxInstanceLockedBy := NEW.pxInstanceLockedBy;
end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				    pxInstanceLockedKey = SPtpxInstanceLockedKey,
				    pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyClassName = SPtpyClassName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
				    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyInterface = SPtpyInterface,
				    pyLabel = SPtpyLabel,
				    pyMethodStatus = SPtpyMethodStatus,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
			            pxInstanceLockedBy = SPtpxInstanceLockedBy,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId,
				    pxInsName ,
				    pxInstanceLockedKey,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyInterface,
				    pyLabel,
				    pyMethodStatus,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
                    		    pxInstanceLockedBy,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,                    		
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
					pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxInstanceLockedKey,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyInterface,
					SPtpyLabel,
					SPtpyMethodStatus,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet ,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
                    			SPtpxInstanceLockedBy,
				    	SPtpzRuleSetVersionMajor,
				    	SPtpzRuleSetVersionMinor,
				    	SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpzClassType);



		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_rule_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_rule_vw_upd
	AFTER INSERT OR UPDATE ON pr4_rule FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_rule_vw_upd();

DROP TRIGGER IF EXISTS trpr4_use ON pr4_rule_usecase CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_use() RETURNS trigger AS $BODY$
declare

--
-- $Id$
--
-- Copyright (c) 2001  Pegasystems Inc.
-- All rights reserved.
--
-- This  software  has  been  provided pursuant  to  a  License
-- Agreement  containing  restrictions on  its  use.   The  software
-- contains  valuable  trade secrets and proprietary information  of
-- Pegasystems Inc and is protected by  federal   copyright law.  It
-- may  not be copied,  modified,  translated or distributed in  any
-- form or medium,  disclosed to third parties or used in any manner
-- not provided for in  said  License Agreement except with  written
-- authorization from Pegasystems Inc.
--
--
-- Name: trpr4_base
--
-- Trigger to gather all updates to the pr_base table.
--
-- Date         Who     RuleProID       Description of Modification
-- 14-Oct-08	ErnsG	Task-3242		change params var to 160 len
-- 14-Oct-08	ErnsG	Task-3242		workaround ampersand syntax in SQL Plus
-- 10-Oct-08	ErnsG	Task-3242		add ruleset to params
-- 09-Jul-07	rajusr	SCH-88			supply value(true/false) for pzParameters column
-- 02-Feb-04	Lawtt	r-12309			Use available Nodename from rule record.
-- 18-Dec-03	SchuD					Create or replace for upgrade
-- 31-Jul-02    GajnJ                   Unify ClearType across all triggers
-- 30-Jul-02    GajnJ                   Initial Work
--
SPtpxSystemName  varchar(32);
SPtpxNodeName    varchar(32);
SPtpzInsKey      varchar(255);
SPtpzObjClass    varchar(64);
SPtpzParameters  varchar(160);
SPtpyRuleSet	varchar(128);

validTrigger	 boolean;

BEGIN

validTrigger := false;

/*
 * Figure out what we're doing, and
 * get the right pzInsKey and
 * pxObjClass
 */
if TG_OP = 'INSERT'  then
	validTrigger := true;
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet;
elsif TG_OP = 'UPDATE' then
	validTrigger := true;
    SPtpzInsKey := NEW.pzInsKey;
    SPtpzObjClass := NEW.pxObjClass;
    SPtpxNodeName := NEW.pxHostId;
    SPtpyRuleSet := NEW.pyRuleSet;
    SPtpzParameters := 'false&'||'pyRuleSet=' || SPtpyRuleSet;
elsif TG_OP = 'DELETE' then
	validTrigger := true;
    SPtpzInsKey := OLD.pzInsKey;
    SPtpzObjClass := OLD.pxObjClass;
    SPtpxNodeName := OLD.pxHostId;
    SPtpyRuleSet := OLD.pyRuleSet;
    SPtpzParameters := 'true&'||'pyRuleSet=' || SPtpyRuleSet;
end if;

/* save the information for pulse processing */
if 	validTrigger then
	insert into PBS_DATA.pr_sys_updatescache(pzKeyString,
	      pzCreateDateTime,
	      pzClearCacheType,
	      pzNodeName,
	      pzSystemName,
	      pzObjClass,
	      pzParameters)
	values (SPtpzInsKey,
	      LOCALTIMESTAMP,
	      'Cache',
	      SPtpxNodeName,
	      SPtpxSystemName,
	      SPtpzObjClass,
	      SPtpzParameters);
	
	/* commit; */
end if;

IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_use() FROM PUBLIC;

CREATE TRIGGER trpr4_use
	AFTER INSERT OR UPDATE OR DELETE ON pr4_rule_usecase FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_use();

DROP TRIGGER IF EXISTS trpr4_use_vw_del ON pr4_rule_usecase CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_use_vw_del() RETURNS trigger AS $BODY$
declare
SPtpzInsKey 	varchar(255);
BEGIN
if TG_OP = 'DELETE' then
	SPtpzInsKey := OLD.pzInsKey;
end if;
delete from PBS_RULES.pr4_rule_vw where pzInsKey = SPtpzInsKey;
RETURN OLD;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_use_vw_del() FROM PUBLIC;

CREATE TRIGGER trpr4_use_vw_del
	AFTER DELETE ON pr4_rule_usecase FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_trpr4_use_vw_del();

DROP TRIGGER IF EXISTS trpr4_use_vw_upd ON pr4_rule_usecase CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_trpr4_use_vw_upd() RETURNS trigger AS $BODY$
declare

SPtpzInsKey varchar(255);
SPtyzInsKeyVw varchar(255);
SPtpxNodeName 	varchar(32);
SPtpxSystemName 	varchar(32);
SPtpzObjClass	varchar(64);
SPtpzObjClasspw  varchar(64);
SPtpzInsKeypw varchar(255);
SPtpxInsId varchar(128);
SPtpxInsName varchar(128);
SPtpxMergeSynchronized timestamp;
SPtpxUpdateDateTime timestamp;
SPtpxUpdateOperator varchar(128);
SPtpxUpdateOpName varchar(128);
SPtpyClassName varchar(64);
SPtpyCircumstanceDate timestamp;
SPtpyCircumstanceDateProp varchar(32);
SPtpyCircumstanceProp varchar(32);
SPtpyCircumstanceType varchar(10);
SPtpyCircumstanceVal varchar(64);
SPtpyLabel varchar(64);
SPtpyRuleAvailable varchar(16);
SPtpyRuleName varchar(128);
SPtpyRuleSet varchar(128);
SPtpyRuleSetVersion varchar(8);
SPtpzRuleSetVersionMajor bigint;
SPtpzRuleSetVersionMinor bigint;
SPtpzRuleSetVersionPatch bigint;
SPtpyRuleStarts timestamp;
SPtpyRuleEnds timestamp;
SPtpxInstanceLockedBy varchar(128);
SPtpxCreateDateTime timestamp;
SPtpyMethodStatus varchar(32);
v_dummy bigint;
SPtpzClassType bigint;
v_classinheritance varchar(5);
v_ruleresolution varchar(5);
v_minorpatch varchar(5);


BEGIN

if TG_OP = 'INSERT' or TG_OP = 'UPDATE' then
	SPtpzInsKey:= NEW.pzInsKey;
    	SPtpxInsId:= NEW.pxInsId;
    	SPtpxInsName:= NEW.pxInsName;
    	SPtpxUpdateDateTime:= NEW.pxUpdateDateTime;
        SPtpxCreateDateTime := NEW.pxCreateDateTime;
        SPtpxMergeSynchronized := NEW.pxMergeSynchronized;
    	SPtpxUpdateOperator:= NEW.pxUpdateOperator;
    	SPtpxUpdateOpName:= NEW.pxUpdateOpName;
    	SPtpyClassName:= NEW.pyClassName;
    	SPtpzObjClasspw:= NEW.pxObjClass;
    	SPtpyCircumstanceDate:= NEW.pyCircumstanceDate;
    	SPtpyCircumstanceDateProp:= NEW.pyCircumstanceDateProp;
    	SPtpyCircumstanceProp:= NEW.pyCircumstanceProp;
	SPtpyCircumstanceType:= NEW.pyCircumstanceType;
    	SPtpyCircumstanceVal:= NEW.pyCircumstanceVal;
    	SPtpyLabel:= NEW.pyLabel;
    	SPtpyRuleAvailable:= NEW.pyRuleAvailable;
    	SPtpyRuleName := NEW.pyRuleName;
    	SPtpyRuleSet:= NEW.pyRuleSet;
    	SPtpyRuleSetVersion:= NEW.pyRuleSetVersion;
    	SPtpzRuleSetVersionMajor:= NEW.pzRuleSetVersionMajor;
    	SPtpzRuleSetVersionMinor:= NEW.pzRuleSetVersionMinor;
    	SPtpzRuleSetVersionPatch:= NEW.pzRuleSetVersionPatch;
    	SPtpyRuleStarts:= NEW.pyRuleStarts;
    	SPtpyRuleEnds:= NEW.pyRuleEnds;
    	SPtpyMethodStatus := NEW.pyMethodStatus;

end if;

if SPtpyRuleSetVersion is null then
	v_minorpatch := '-1';
else
	v_minorpatch := substr(SPtpyRuleSetVersion, 4, 5);
end if;

	SELECT count(1) INTO STRICT v_dummy
	          FROM PBS_RULES.pr4_rule_vw WHERE pzInsKey = SPtpzInsKey;
	SELECT pyClassInheritance,
	pyRuleResolution
	into STRICT v_classinheritance,
	v_ruleresolution
	FROM PBS_RULES.pr4_base
	WHERE pyClassName = SPtpzObjClasspw
	AND pyClassType        = 'Concrete'
	AND pxObjClass           = 'Rule-Obj-Class'   LIMIT 1;

	if v_classinheritance='true' and v_ruleresolution='true' then
	SptpzClassType := 0;
	elsif v_classinheritance='false' and v_ruleresolution='true' then
	SPtpzClassType :=1;
	elsif  v_classinheritance='false' and v_ruleresolution='false' then
	SptpzClassType :=2;
	end if;

	    IF SPtpzInsKey LIKE 'RULE-%' THEN
        IF v_dummy > 0 THEN


			update PBS_RULES.pr4_rule_vw
				 set
				 	pxMergeSynchronized = SPtpxMergeSynchronized,
				    pxUpdateDateTime = SPtpxUpdateDateTime,
            			    pxCreateDateTime = SPtpxCreateDateTime,
				    pxUpdateOperator = SPtpxUpdateOperator ,
				    pxUpdateOpName = SPtpxUpdateOpName,
				    pyCircumstanceDate = SPtpyCircumstanceDate,
				    pyCircumstanceDateProp = SPtpyCircumstanceDateProp,
				    pyCircumstanceProp = SPtpyCircumstanceProp,
            			    pyCircumstanceType = SPtpyCircumstanceType,
				    pyCircumstanceVal = SPtpyCircumstanceVal,
				    pyLabel = SPtpyLabel,
				    pyRuleAvailable = SPtpyRuleAvailable,
				    pyRuleName = SPtpyRuleName,
				    pyRuleSet = SPtpyRuleSet,
				    pyRuleSetVersion = SPtpyRuleSetVersion,
				    pyRuleStarts = SPtpyRuleStarts,
				    pyRuleEnds = SPtpyRuleEnds,
				    pzRuleSetVersionMajor = SPtpzRuleSetVersionMajor,
				    pzRuleSetVersionMinor = SPtpzRuleSetVersionMinor,
				    pzRuleSetVersionPatch = SPtpzRuleSetVersionPatch,
					pzRuleSetVersionMinorPatch = v_minorpatch,
				    pyMethodStatus = SPtpyMethodStatus,
					pzClassType = SPtpzClassType
			where pzInsKey = SPtpzInsKey;


		else

				insert into PBS_RULES.pr4_rule_vw(pxObjClass,
				    pxInsId ,
				    pxInsName ,
				    pxMergeSynchronized,
				    pxUpdateDateTime,
            			    pxCreateDateTime,
				    pxUpdateOperator,
				    pxUpdateOpName,
				    pyClass,
				    pyClassName,
				    pyCircumstanceDate,
				    pyCircumstanceDateProp,
				    pyCircumstanceProp,
				    pyCircumstanceType,
				    pyCircumstanceVal,
				    pyLabel,
				    pyRuleAvailable,
				    pyRuleName,
				    pyRuleSet,
				    pyRuleSetVersion,
				    pyRuleStarts,
				    pyRuleEnds,
				    pzRuleSetVersionMajor,
				    pzRuleSetVersionMinor,
				    pzRuleSetVersionPatch,
				    pzRuleSetVersionMinorPatch,
				    pzInsKey,
				    pyMethodStatus,
				    pzClassType)
				values ('Data-Rule-Summary',
					SPtpxInsId,
					SPtpxInsName,
					SPtpxMergeSynchronized,
					SPtpxUpdateDateTime,
          				SPtpxCreateDateTime,
					SPtpxUpdateOperator,
					SPtpxUpdateOpName,
					SPtpzObjClasspw,
					SPtpyClassName,
					SPtpyCircumstanceDate,
					SPtpyCircumstanceDateProp,
					SPtpyCircumstanceProp,
					SPtpyCircumstanceType,
					SPtpyCircumstanceVal,
					SPtpyLabel,
					SPtpyRuleAvailable,
					SPtpyRuleName,
					SPtpyRuleSet,
					SPtpyRuleSetVersion,
					SPtpyRuleStarts,
					SPtpyRuleEnds,
				    SPtpzRuleSetVersionMajor,
				    SPtpzRuleSetVersionMinor,
				    SPtpzRuleSetVersionPatch,
				    v_minorpatch,
					SPtpzInsKey,
					SPtpyMethodStatus,
					SPtpzClassType
				);



		end if;
		end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_trpr4_use_vw_upd() FROM PUBLIC;

CREATE TRIGGER trpr4_use_vw_upd 
AFTER INSERT OR UPDATE ON "pbs_rules"."pr4_rule_usecase" FOR EACH ROW
	WHEN (new.pzInsKey like 'RULE-%')
	EXECUTE PROCEDURE trigger_fct_trpr4_use_vw_upd();

